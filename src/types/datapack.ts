
import { z } from 'zod';

// #region New Granular RPG Schema

/**
 * Represents the different types of gear that can be equipped in a single body slot.
 * This is the core of the new granular system.
 */
export interface EquipmentSlotOptions {
  clothing?: { label: string; value: string }[];
  armor?: { label: string; value: string }[];
  accessory?: { label: string; value: string }[];
  weapon?: { label: string; value: string }[];
}

/**
 * Defines the available options for each part of a structured character profile.
 * This will be generated by the AI and stored in the DataPack.
 */
export interface CharacterProfileSchema {
  // General
  count: { label: string; value: string }[];
  raceClass: { label: string; value: string }[];
  gender: { label: string; value: string }[];

  // Appearance
  hair: { label: string; value: string }[];
  eyes: { label: string; value: string }[];
  skin: { label: string; value: string }[];
  facialFeatures: { label: string; value: string }[];

  // Equipment Slots
  head: EquipmentSlotOptions;
  face: EquipmentSlotOptions;
  neck: EquipmentSlotOptions;
  shoulders: EquipmentSlotOptions;
  torso: EquipmentSlotOptions;
  arms: EquipmentSlotOptions;
  hands: EquipmentSlotOptions;
  waist: EquipmentSlotOptions;
  legs: EquipmentSlotOptions;
  feet: EquipmentSlotOptions;
  back: EquipmentSlotOptions;

  // Extra weapons
  weaponsExtra: { label: string; value: string }[];

  // Scene
  pose: { label: string; value:string }[];
  action: { label: string; value: string }[];
  camera: { label: string; value: string }[];
  background: { label: string; value: string }[];
  effects: { label: string; value: string }[];
}

// #endregion


// Base Interfaces for type-checking in TS
export interface Exclusion {
    slotId: string;
    optionValues: string[];
}

export interface Option {
    label: string;
    value: string;
    tags?: string[]; // Used for simple tag-based generation
    exclusions?: Exclusion[];
}

export interface Slot {
    id: string;
    label: string;
    type?: 'text' | 'select';
    options?: Option[];
    defaultOption?: string;
    placeholder?: string;
    isLocked?: boolean;
}

export interface PromptTemplate {
    name: string;
    template: string; // A full sentence template with {slot_id} placeholders
}

/**
 * The main schema for a DataPack, now supporting both old and new systems.
 */
export interface DataPackSchema {
    // Legacy system
    promptTemplates?: PromptTemplate[];
    slots?: Slot[];
    
    // New RPG Inventory system
    characterProfileSchema?: CharacterProfileSchema;
    
    // Common fields
    tags?: string[];
}

export interface DataPack {
    id: string;
    name:string;
    author: string;
    description: string;
    coverImageUrl: string | null;
    type: 'free' | 'premium' | 'temporal';
    price: number;
    tags: string[];
    createdAt: number;
    updatedAt?: number | null;
    schema: DataPackSchema;
    isNsfw?: boolean;
}

// Zod Schemas for validation (both client and server)

// This part is now primarily for the LEGACY editor. The new system will need a new Zod schema
// if we build a form for it, but for AI generation, the TS types are sufficient for now.
export const ExclusionSchema = z.object({
    slotId: z.string().min(1, 'Target Slot ID is required.'),
    optionValues: z.array(z.string()).min(1, 'At least one option value is required.'),
});

export const OptionSchema = z.object({
    label: z.string().min(1, 'Label is required.'),
    value: z.string().min(1, 'Value is required.'),
    tags: z.array(z.string()).optional(),
    exclusions: z.array(ExclusionSchema).optional(),
});

export const SlotSchema = z.object({
    id: z.string().min(1, 'ID is required.'),
    label: z.string().min(1, 'Label is required.'),
    type: z.enum(['text', 'select']).default('select'),
    options: z.array(OptionSchema).optional(),
    defaultOption: z.string().optional(),
    placeholder: z.string().optional(),
    isLocked: z.boolean().optional(),
});

export const PromptTemplateSchema = z.object({
  name: z.string().min(1, 'Template name is required.'),
  template: z.string().min(1, 'Template string is required.'),
});


export const DataPackSchemaSchema = z.object({
    promptTemplates: z.array(PromptTemplateSchema).min(1, 'At least one prompt template is required.').optional(),
    slots: z.array(SlotSchema).min(1, 'At least one slot is required.').optional(),
    // We don't need to validate the new schema with Zod for now as it's AI-generated
    characterProfileSchema: z.any().optional(),
    tags: z.array(z.string()).optional(),
});

// Used for the entire form in the admin panel
export const DataPackFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  author: z.string().min(1, 'Author is required'),
  description: z.string().min(1, 'Description is required'),
  type: z.enum(['free', 'premium', 'temporal']),
  price: z.number().min(0),
  tags: z.array(z.string()).optional(),
  schema: DataPackSchemaSchema,
  isNsfw: z.boolean().optional(),
});

// Used for the server action (upsert)
export const UpsertDataPackSchema = DataPackFormSchema.extend({
    id: z.string().optional(),
});

// TypeScript types inferred from Zod schemas
export type DataPackFormValues = z.infer<typeof DataPackFormSchema>;
export type UpsertDataPack = z.infer<typeof UpsertDataPackSchema>;
