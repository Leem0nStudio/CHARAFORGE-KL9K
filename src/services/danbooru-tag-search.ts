
'use server';
/**
 * @fileOverview A service for searching Danbooru tags from a pre-processed local file.
 * This service reads from `data/danbooru-tags.json`, which is generated by the
 * `scripts/fetch-danbooru-tags.ts` script. This approach provides fast and reliable
 * tag searching without making live API calls during user sessions.
 *
 * The primary function exported is `searchTags`, which is designed to be used as a
 * Tool by Genkit flows.
 */

import { z } from 'zod';
import * as fs from 'fs/promises';
import * as path from 'path';

// #region Type Definitions
interface ProcessedTag {
    name: string;
    post_count: number;
}

type CategorizedTags = Record<string, ProcessedTag[]>;
// #endregion

// Memoization cache for the tag database to avoid reading the file on every call.
let tagDatabase: CategorizedTags | null = null;

/**
 * Loads the tag database from the local JSON file.
 * Caches the result in memory after the first read.
 * @returns {Promise<CategorizedTags>} A promise that resolves to the categorized tag data.
 */
async function getTagDatabase(): Promise<CategorizedTags> {
    if (tagDatabase) {
        return tagDatabase;
    }

    const filePath = path.join(process.cwd(), 'data', 'danbooru-tags.json');
    try {
        const fileContent = await fs.readFile(filePath, 'utf-8');
        tagDatabase = JSON.parse(fileContent);
        return tagDatabase!;
    } catch (error) {
        console.error(`Failed to load or parse tag database from ${filePath}. Please ensure the file exists and is valid. You may need to run 'npm run tags:fetch'.`, error);
        // Return an empty structure to prevent crashes.
        return { headwear: [], topwear: [], bottomwear: [] };
    }
}


// #region Tag Search Service
export const SearchTagsInputSchema = z.object({
  query: z.string().describe("A simple, one or two-word search term (e.g., 'hat', 'skirt', 'armor')."),
  category: z.enum(['headwear', 'topwear', 'bottomwear', 'general']).optional().describe("The category to search within. If 'general', search all categories."),
});
export type SearchTagsInput = z.infer<typeof SearchTagsInputSchema>;

export const SearchTagsOutputSchema = z.array(z.string()).describe("A list of matching tag names.");
export type SearchTagsOutput = z.infer<typeof SearchTagsOutputSchema>;


/**
 * Searches the pre-processed tag database file for relevant tags.
 * @param input - The search parameters, including the query and optional category.
 * @returns A promise that resolves to a list of matching tag names, sorted by popularity.
 */
export async function searchTags(input: SearchTagsInput): Promise<SearchTagsOutput> {
    const { query, category } = input;
    const db = await getTagDatabase();
    const searchTerm = query.toLowerCase().replace(/s$/, ''); // Basic pluralization removal

    let tagsToSearch: ProcessedTag[] = [];

    if (category && category !== 'general' && db[category]) {
        tagsToSearch = db[category];
    } else {
        // If general or no category, search all. Flatten the arrays from all categories.
        tagsToSearch = Object.values(db).flat();
    }

    const results = tagsToSearch
        // The file is already sorted by post_count, so we just need to filter.
        .filter(tag => tag.name.includes(searchTerm))
        .map(tag => tag.name);

    return results.slice(0, 10); // Return top 10 matches
}
// #endregion
